<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D 全息投影產生器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #000;
            overflow: hidden;
            touch-action: none; /* Prevent scrolling */
        }
        
        /* The container for the 4 images */
        #hologram-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vmin;
            height: 100vmin;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Common styles for the projection quadrants */
        .projection {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            transition: all 0.2s ease-out;
        }

        .projection img, .projection video, .projection .demo-shape {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Demo animation shape */
        .demo-shape {
            width: 60%;
            height: 60%;
            border: 5px solid cyan;
            border-radius: 50%;
            box-shadow: 0 0 20px cyan, inset 0 0 20px cyan;
            animation: pulse-spin 3s infinite linear;
        }

        @keyframes pulse-spin {
            0% { transform: scale(0.8) rotate(0deg); opacity: 0.8; border-color: cyan; box-shadow: 0 0 20px cyan; }
            50% { transform: scale(1.1) rotate(180deg); opacity: 1; border-color: magenta; box-shadow: 0 0 30px magenta; }
            100% { transform: scale(0.8) rotate(360deg); opacity: 0.8; border-color: cyan; box-shadow: 0 0 20px cyan; }
        }

        /* Positioning and Rotation logic */
        /* Top (Up) - Rotated 180deg */
        .pos-top {
            transform: translateY(var(--offset-y-neg)) rotate(180deg);
            width: var(--size);
            height: var(--size);
        }

        /* Bottom (Down) - Normal 0deg */
        .pos-bottom {
            transform: translateY(var(--offset-y-pos)) rotate(0deg);
            width: var(--size);
            height: var(--size);
        }

        /* Left - Rotated 90deg */
        .pos-left {
            transform: translateX(var(--offset-x-neg)) rotate(90deg);
            width: var(--size);
            height: var(--size);
        }

        /* Right - Rotated -90deg */
        .pos-right {
            transform: translateX(var(--offset-x-pos)) rotate(-90deg);
            width: var(--size);
            height: var(--size);
        }

        /* Alignment Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 10;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
        }
        #crosshair::before { width: 100%; height: 2px; top: 9px; }
        #crosshair::after { height: 100%; width: 2px; left: 9px; }

        /* Control Panel */
        #controls {
            transition: opacity 0.5s;
        }
        .hidden-ui {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body class="text-white font-sans antialiased">

    <!-- Hologram Area -->
    <div id="hologram-container" style="--size: 150px; --offset-y-neg: -100px; --offset-y-pos: 100px; --offset-x-neg: -100px; --offset-x-pos: 100px;">
        <div id="crosshair"></div>
        
        <!-- Top -->
        <div class="projection pos-top">
            <div class="content-slot"><div class="demo-shape"></div></div>
        </div>
        <!-- Bottom -->
        <div class="projection pos-bottom">
            <div class="content-slot"><div class="demo-shape"></div></div>
        </div>
        <!-- Left -->
        <div class="projection pos-left">
            <div class="content-slot"><div class="demo-shape"></div></div>
        </div>
        <!-- Right -->
        <div class="projection pos-right">
            <div class="content-slot"><div class="demo-shape"></div></div>
        </div>
    </div>

    <!-- UI Controls -->
    <div id="controls" class="fixed bottom-0 left-0 right-0 p-4 bg-gray-900 bg-opacity-90 backdrop-blur-sm border-t border-gray-700 z-50 flex flex-col md:flex-row gap-4 items-center justify-between">
        
        <div class="flex flex-col gap-2 w-full md:w-auto">
            <h1 class="text-lg font-bold text-cyan-400">iPad 全息投影模板</h1>
            <p class="text-xs text-gray-400">將透明金字塔置於螢幕中心的十字準星處</p>
        </div>

        <div class="flex flex-wrap gap-4 items-center justify-center w-full md:w-auto">
            <!-- Upload -->
            <label class="cursor-pointer bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg text-sm flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                上傳圖片/影片
                <input type="file" id="fileInput" accept="image/*,video/*" class="hidden">
            </label>

            <!-- Sliders -->
            <div class="flex flex-col gap-1 w-32">
                <label class="text-xs text-gray-400 flex justify-between">影像大小 <span id="sizeVal">150</span></label>
                <input type="range" id="sizeRange" min="50" max="400" value="150" class="w-full accent-cyan-500">
            </div>

            <div class="flex flex-col gap-1 w-32">
                <label class="text-xs text-gray-400 flex justify-between">中心距離 <span id="distVal">100</span></label>
                <input type="range" id="distRange" min="0" max="300" value="100" class="w-full accent-cyan-500">
            </div>
            
            <!-- Mirror Toggle -->
             <label class="flex items-center gap-2 cursor-pointer text-sm">
                <input type="checkbox" id="mirrorCheck" class="rounded bg-gray-700 border-gray-600 text-cyan-500 focus:ring-cyan-500">
                <span>鏡像翻轉</span>
            </label>
        </div>

        <div class="flex gap-2 w-full md:w-auto justify-end">
             <button id="toggleUIBtn" class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-lg text-sm">
                隱藏面板
            </button>
        </div>
    </div>

    <!-- Hidden UI Overlay Trigger (Invisible full screen button to bring UI back) -->
    <div id="uiTrigger" class="fixed inset-0 z-40 hidden" style="background: transparent;"></div>

    <script>
        const container = document.getElementById('hologram-container');
        const fileInput = document.getElementById('fileInput');
        const sizeRange = document.getElementById('sizeRange');
        const distRange = document.getElementById('distRange');
        const sizeVal = document.getElementById('sizeVal');
        const distVal = document.getElementById('distVal');
        const contentSlots = document.querySelectorAll('.content-slot');
        const controls = document.getElementById('controls');
        const toggleUIBtn = document.getElementById('toggleUIBtn');
        const uiTrigger = document.getElementById('uiTrigger');
        const mirrorCheck = document.getElementById('mirrorCheck');

        // State
        let currentSize = 150;
        let currentDist = 100;

        // Update CSS Variables based on slider input
        function updateLayout() {
            container.style.setProperty('--size', `${currentSize}px`);
            
            // Distance from center calculation
            // We use translate to push them out from center
            container.style.setProperty('--offset-y-neg', `-${currentDist}px`);
            container.style.setProperty('--offset-y-pos', `${currentDist}px`);
            container.style.setProperty('--offset-x-neg', `-${currentDist}px`);
            container.style.setProperty('--offset-x-pos', `${currentDist}px`);

            sizeVal.textContent = currentSize;
            distVal.textContent = currentDist;
        }

        sizeRange.addEventListener('input', (e) => {
            currentSize = e.target.value;
            updateLayout();
        });

        distRange.addEventListener('input', (e) => {
            currentDist = e.target.value;
            updateLayout();
        });

        // Mirror Toggle
        mirrorCheck.addEventListener('change', (e) => {
            const scaleX = e.target.checked ? -1 : 1;
            contentSlots.forEach(slot => {
                slot.style.transform = `scaleX(${scaleX})`;
            });
        });

        // File Handling
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            const isVideo = file.type.startsWith('video/');

            contentSlots.forEach(slot => {
                slot.innerHTML = ''; // Clear demo shape
                
                let el;
                if (isVideo) {
                    el = document.createElement('video');
                    el.src = url;
                    el.loop = true;
                    el.muted = true; // Required for autoplay on many devices
                    el.playsInline = true;
                    el.autoplay = true;
                    el.style.width = '100%';
                    el.style.height = '100%';
                    el.style.objectFit = 'contain';
                    // Sync play
                    el.play().catch(err => console.log("Autoplay prevented", err));
                } else {
                    el = document.createElement('img');
                    el.src = url;
                    el.style.width = '100%';
                    el.style.height = '100%';
                    el.style.objectFit = 'contain';
                }
                slot.appendChild(el);
            });
        });

        // UI Toggle
        toggleUIBtn.addEventListener('click', () => {
            controls.classList.add('hidden-ui');
            uiTrigger.classList.remove('hidden');
            // Show a temporary hint maybe?
        });

        uiTrigger.addEventListener('click', () => {
            controls.classList.remove('hidden-ui');
            uiTrigger.classList.add('hidden');
        });

        // Initial setup
        updateLayout();

        // Handle video sync (if one loops, ensure others stay relatively synced)
        // This is a basic implementation. Ideally, you'd use a single source and canvas, 
        // but for a simple DOM template, this is sufficient.
        setInterval(() => {
            const videos = document.querySelectorAll('video');
            if (videos.length > 0) {
                const first = videos[0];
                if (!first.paused && !first.ended) {
                    for (let i = 1; i < videos.length; i++) {
                        // If drift is significant (> 0.1s), resync
                        if (Math.abs(videos[i].currentTime - first.currentTime) > 0.1) {
                            videos[i].currentTime = first.currentTime;
                        }
                        if (videos[i].paused) videos[i].play();
                    }
                }
            }
        }, 1000);

    </script>
</body>
</html>
